/**
 * SVGExporter Class
 * Assembles optimized paths into final SVG document and handles download
 */
class SVGExporter {
  constructor() {
    this.svgNamespace = 'http://www.w3.org/2000/svg';
  }
  
  /**
   * Export paths to SVG string
   * @param {Array<Object>} paths - Array of {d, fill} path objects
   * @param {number} width - SVG width
   * @param {number} height - SVG height
   * @returns {string} - Complete SVG document string
   */
  export(paths, width, height) {
    try {
      // Start SVG document
      let svg = `<?xml version="1.0" encoding="UTF-8"?>\n`;
      svg += `<svg xmlns="${this.svgNamespace}" `;
      svg += `width="${width}" `;
      svg += `height="${height}" `;
      svg += `viewBox="0 0 ${width} ${height}">\n`;
      
      // Add title and description
      svg += `  <title>Vectorized Image</title>\n`;
      svg += `  <desc>Generated by SVGify - Advanced Image Vectorization</desc>\n`;
      
      // Add paths (background to foreground order)
      for (const path of paths) {
        if (!path.d || path.d.trim() === '') {
          continue; // Skip empty paths
        }
        
        svg += `  <path `;
        svg += `d="${this.escapeSvgAttribute(path.d)}" `;
        svg += `fill="${path.fill}" `;
        svg += `fill-rule="evenodd" `;
        svg += `stroke="none"/>\n`;
      }
      
      // Close SVG
      svg += `</svg>`;
      
      return svg;
      
    } catch (error) {
      throw new ExportError(`SVG export error: ${error.message}`);
    }
  }
  
  /**
   * Escape special characters in SVG attributes
   * @param {string} str - String to escape
   * @returns {string} - Escaped string
   */
  escapeSvgAttribute(str) {
    return str
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&apos;');
  }
  
  /**
   * Download SVG file
   * @param {string} svgContent - SVG content string
   * @param {string} filename - Optional filename
   */
  download(svgContent, filename = null) {
    try {
      // Generate filename if not provided
      if (!filename) {
        const timestamp = new Date().getTime();
        filename = `vectorized-${timestamp}.svg`;
      }
      
      // Ensure .svg extension
      if (!filename.endsWith('.svg')) {
        filename += '.svg';
      }
      
      // Create Blob
      const blob = new Blob([svgContent], { type: 'image/svg+xml;charset=utf-8' });
      
      // Use FileSaver if available, otherwise fallback
      if (typeof saveAs !== 'undefined') {
        saveAs(blob, filename);
      } else {
        this.downloadFallback(blob, filename);
      }
      
    } catch (error) {
      throw new ExportError(`Download error: ${error.message}`);
    }
  }
  
  /**
   * Fallback download method without FileSaver
   * @param {Blob} blob - File blob
   * @param {string} filename - Filename
   */
  downloadFallback(blob, filename) {
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.style.display = 'none';
    
    document.body.appendChild(a);
    a.click();
    
    // Cleanup
    setTimeout(() => {
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }, 100);
  }
  
  /**
   * Export to data URL
   * @param {string} svgContent - SVG content
   * @returns {string} - Data URL
   */
  toDataURL(svgContent) {
    const base64 = btoa(unescape(encodeURIComponent(svgContent)));
    return `data:image/svg+xml;base64,${base64}`;
  }
  
  /**
   * Export with custom options
   * @param {Array<Object>} paths - Path objects
   * @param {number} width - Width
   * @param {number} height - Height
   * @param {Object} options - Custom options
   * @returns {string} - SVG string
   */
  exportWithOptions(paths, width, height, options = {}) {
    const {
      title = 'Vectorized Image',
      description = 'Generated by SVGify',
      background = null,
      strokeWidth = 0,
      strokeColor = 'none'
    } = options;
    
    let svg = `<?xml version="1.0" encoding="UTF-8"?>\n`;
    svg += `<svg xmlns="${this.svgNamespace}" `;
    svg += `width="${width}" `;
    svg += `height="${height}" `;
    svg += `viewBox="0 0 ${width} ${height}">\n`;
    
    svg += `  <title>${this.escapeSvgAttribute(title)}</title>\n`;
    svg += `  <desc>${this.escapeSvgAttribute(description)}</desc>\n`;
    
    // Add background if specified
    if (background) {
      svg += `  <rect width="${width}" height="${height}" fill="${background}"/>\n`;
    }
    
    // Add paths
    for (const path of paths) {
      if (!path.d || path.d.trim() === '') continue;
      
      svg += `  <path `;
      svg += `d="${this.escapeSvgAttribute(path.d)}" `;
      svg += `fill="${path.fill}" `;
      svg += `fill-rule="evenodd" `;
      
      if (strokeWidth > 0) {
        svg += `stroke="${strokeColor}" `;
        svg += `stroke-width="${strokeWidth}" `;
      } else {
        svg += `stroke="none" `;
      }
      
      svg += `/>\n`;
    }
    
    svg += `</svg>`;
    
    return svg;
  }
  
  /**
   * Calculate SVG file size
   * @param {string} svgContent - SVG content
   * @returns {number} - Size in bytes
   */
  getFileSize(svgContent) {
    return new Blob([svgContent]).size;
  }
  
  /**
   * Format file size for display
   * @param {number} bytes - Size in bytes
   * @returns {string} - Formatted size string
   */
  formatFileSize(bytes) {
    if (bytes < 1024) {
      return `${bytes} B`;
    } else if (bytes < 1024 * 1024) {
      return `${(bytes / 1024).toFixed(2)} KB`;
    } else {
      return `${(bytes / (1024 * 1024)).toFixed(2)} MB`;
    }
  }
}
